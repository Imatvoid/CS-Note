## 归并排序



## 思路

归并排序（MERGE-SORT）是利用**归并**的思想实现的排序方法，该算法采用经典的**分治**（divide-and-conquer）策略（分治法将问题**分**(divide)成一些小的问题然后递归求解，而**治(conquer)**的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。

![image-20190530115600789](归并排序/image-20190530115600789.png)

![image-20190530160449181](归并排序/image-20190530160449181.png)



## 实现

```java
class MergeSort {


    public static void main(String[] args) {
        int[] nums = new int[]{1, 14, 5869, 2, -1, 88, 9, 9, 3};
        int[] temp = new int[nums.length];
        new MergeSort().mergeSort(nums, 0, nums.length - 1, temp);

        // break point
        System.out.print("");

    }

    void mergeSort(int[] nums, int start, int end, int[] temp) {
        if (start < end) {
            int mid = start + (end - start) / 2;
            // 先分
            mergeSort(nums, start, mid, temp);
            mergeSort(nums, mid + 1, end, temp);
            
            //然后合并
            mergeArray(nums, start, mid, end, temp);

        }


    }

    void mergeArray(int[] nums, int start, int mid, int end, int[] temp) {

        int i1 = start, j1 = mid;
        int i2 = mid + 1, j2 = end;
        int k = 0;
        while (i1 <= j1 && i2 <= j2) {
            if (nums[i1] <= nums[i2]) {
                temp[k++] = nums[i1++];
            } else {
                temp[k++] = nums[i2++];
            }
        }
        // 如果i1短，则i1=j1+1
        while (i1 <= j1) {
            temp[k++] = nums[i1++];
        }
        // 如果i2短，则i2=j2+1
        while (i2 <= j2) {
            temp[k++] = nums[i2++];
        }
        
        // temp对每次合并操作都是临时数组，使用效率在最后一次是100%
        k = 0;
        
        //在合适的start-end 对nums进行排序赋值
        while (start <= end) {
            nums[start++] = temp[k++];
        }


    }
}
```


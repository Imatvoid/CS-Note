#!/bin/bash

echo 当前时间：--------------------------------------
echo `date`

echo UTC时间钟：--------------------------------------
echo `date +%s`

echo 获取时间:--------------------------------------
echo `date --date "Thu Nov 18 08:07:21 IST 2010" +%s`


#星期  %a(例如:Sat)  %A(例如:Saturday)
#月    %b(例如:Nov)  %B(例如:November)  %m(11)
#日    %d(例如:31)
#固定格式日期(mm/dd/yy) %D(例如:10/18/10)
#年    %y(例如:10) %Y(例如:2010)
#小时 %I或%H(例如:08)
#分钟 %M(例如:33)
#秒 %S(例如:10)
#纳秒 %N(例如:695208515)
#Unix纪元时(以秒为单位) %s(例如:1290049486)

echo 格式:--------------------------------------
echo `date "+%d %B %Y"`

echo `date "+%d %m %Y"`





yesterday=`date -d last-day +%Y-%m-%d`
echo $yesterday
 
curday=`date +%Y-%m-%d`
echo $curday
 
echo "现在时间：`date '+%Y%m%d %T'`"
echo "现在时间：`date '+%Y%m%d %H%M%S'`"
 
echo `date '+%Y%m%d-%H%M%S'`
 
t3=`date '+%Y-%m-%d %H:%M:%S'`
echo $t3
 
send=`date '+%Y-%m-%d %H:%M:%S'`
echo $send
 
t4=`date '+%Y-%m-%d %H:%M:%S'`



echo 计算时间差：--------------------------------------
start=$(date +%s)

sleep 5

end=$(date +%s)
difference=$(( end - start))
echo Time taken to execute commands is $difference seconds.



#!/bin/bash
echo --------- 1-----------
array_var=(1 2 3 4 5 6)

echo $array_var
echo ${array_var[1]}

echo ----------2------------
array_var[0]="test1"
array_var[1]="test2"
array_var[2]="test3"
array_var[3]="test4"
array_var[4]="test5"
array_var[5]="test6"

echo ${array_var[*]}

echo ----------3------------


echo "打印数组长度:"
echo ${#array_var[*]}






#定义关联数组
echo ----------4关联数组------------
declare -A fruits_value
fruits_value=([apple]='100dollars' [orange]='150 dollars')
echo "Apple costs ${fruits_value[apple]}"


declare -A fruits_value
fruits_value=([apple]=100dollars [orange]=150dollars)
echo "Apple costs ${fruits_value[apple]}"

echo 获得数组索引:
echo ${!fruits_value[*]}




#!/bin/bash


# 目录所有文件
#echo `find .`


#print 指明打印出匹配文件的文件名(路径)。当使用 -print 时, '\n' 作为用于对输出的文件名进行分隔。就算你忽略 -print , find 命令仍会打印出文件名。
echo ----------find    -----------------

echo `find . -print`
#-print0 指明使用 '\0' 作为匹配的文件名之间的定界符。当文件名中包含换行符时,这个方法就有用武之地了。
#echo `find . -print0`

echo ----------find *.sh-----------------
echo `find . -name "*.sh" -print`  # 忽略大小写 echo `find . -iname "*.sh" -print`

echo ----------find or-----------------

echo `find . \( -name "f*.sh" -o -name "a*.sh" \) -print`


echo ----------find path-----------------

echo `find . -path "*/dir1/*" -print`

echo ----------find regex-----------------

echo `find . -regex ".*\(\.py\|\.sh\)$"` # find . -iregex ".*\(\.py\|\.sh\)$"


echo ----------find ! *.sh-----------------
echo `find . ! -name "*.sh" -print`


echo ----------find depth-----------------
echo `find . -maxdepth 1 -name "f*" -print`

echo `find . -mindepth 2 -name "*f*" -print`


echo ----------find by type-----------------

echo  dir: `find . -type d -print`

echo  file: `find . -type f -print`

echo linkfile: `find . -type l -print`

echo ----------find by time-----------------
#访问时间( -atime ) 用户最近一次访问文件的时间。
#修改时间( -mtime ) 文件内容最后一次被修改的时间。
#变化时间( -ctime ) 文件元数据(例如权限或所有权)最后一次改变的时间。
#计量单位是“天”
echo 7天内被访问过的文件: `find . -type f -atime -7 -print`
echo 打印出访问时间超过7天的所有文件: `find . -type f -atime +7 -print`


#访问时间( -amin ) 用户最近一次访问文件的时间。
#修改时间( -mmin ) 文件内容最后一次被修改的时间。
#变化时间( -cmin ) 文件元数据(例如权限或所有权)最后一次改变的时间。
echo 打印出访问时间超过7分钟的所有文件: `find . -type f -amin +7 -print`


echo 比alias.sh修改时间更近的所有文件: `find . -type f -newer alias.sh -print`


echo ----------find by size-----------------

echo 大于2KB的文件: `find . -type f -size +2k`

echo 小于2KB的文件: `find . -type f -size -2k`

echo 等于2KB的文件: `find . -type f -size 2k`
#b —— 块(512字节)
#c —— 字节。
#w —— 字(2字节)
#k —— 1024字节。
#M —— 1024K字节。
#G —— 1024M字节。

echo  ----------find by perm-----------------

echo 打印出权限为764的文件: `find . -type f -perm 764 -print`

echo ----------find and rm----------------- 
#find . -type f -name "*.swp" -delete
#



echo ----------find by user----------------- 
echo 打印出用户atvoid拥有的所有文件: `find . -type f -user atvoid -print`


echo ----------find by exec----------------- # find 命令可以借助选项 -exec 与其他命名进行结合。 -exec 算得上是 find 最强大的特性之一。
#echo `find . -type f -user root -exec chown slynux {} \;`
#有时候我们并不希望对每个文件都执行一次命令。我们更希望使用文件列表作为命令参数,这样就可以少运行几次命令了。如果是这样,可以在 exec 中使
#用 + 来代替 ; 。

find . -type f -name "*.sh" -exec cat {} \;>all_sh_files.txt

# 我们无法在 -exec 参数中直接使用多个命令。它只能够接受单个命令,不过
#我们可以耍一个小花招。把多个命令写到一个shell脚本中(例如 command.sh ),然
#后在 -exec 中使用这个脚本:


find . -type f -name "*.sh" -exec printf "sh file: %s\n" {} \;































#!/bin/bash

echo "检查是否默认情况下shell脚本中是否开启alias扩展"
shopt expand_aliases 



#shopt [-psu] [optname …]
#-s 开启某个选项.
#-u 关闭某个选项.
#-p 列出所有选项的当前生效命令. （不带-p表示列出所有选项的当前状态）

echo "shell中开启alias扩展"
shopt -s  expand_aliases  

alias install='sudo apt-get install'

alias echo2='echo'

echo2 我使用的是echo2

alias rm='cp $@ ~/backup && rm $@'
#!/bin/bash
#声明函数
fname()
{
echo 我是一个函数
}
#  调用函数
fname ;



fadd()
{
echo `expr $1 + $2`
}
fadd 1 2


fname2()
{
echo $1, $2; #访问参数1和参数2
echo "$@"; #以列表的方式一次性打印所有参数
echo "$*"; #类似于$@,但是参数被作为单个实体
return 0; #返回值
}


fadd2()
{
return `expr $1 + $2`;
}
fadd2 255 2

if [ $? -eq 0 ];
then
echo "executed successfully"
else
echo "terminated unsuccessfully"
fi

#export
#export -f fname













#!/bin/bash
#上面的是shebang 当脚本独自运行时候的解释器位置,当脚本作为命令行参数运行时 不需要 

# echo
fruit=apple
count=5
echo 'We have $count ${fruit}(s)'
echo "We have $count ${fruit}(s)"


# 字符串长度
var=12345678901234567890$
echo ${#var}

# 使用的shell 
echo $SHELL

#文件名
echo $0


# 是否是超级用户
if [ $UID -ne 0 ]; then
   echo Non root user. Please run as root.
else
   echo Root user
fi



#变量	含义
#$0	当前脚本的文件名
#$n	传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。
#$#	传递给脚本或函数的参数个数。
#$*	传递给脚本或函数的所有参数。
#$@	传递给脚本或函数的所有参数。被双引号(" ")包含时，与 $* 稍有不同。
#$?	上个命令的退出状态，或函数的返回值。
#$$	当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。
#!/bin/bash


# -d代表存在 
prepend2() { [ -d "$2" ] && eval $1=\"$2':'\$$1\" && export $1; }


prepend(){ [ -d "$2" ] && eval $1=\"$2\$\{$1:+':'\$$1\}\" && export $1 ; }

                   
prepend3(){ 
  if [ -d "$2" ];then
    #eval PATH=
    eval $1=\"$2\$\{$1:+':'\$$1\}\"            
    #export $1; 
  fi
}


prepend3 $1 $2

echo $PATH


#!/bin/bash

#在Bash shell环境中,可以利用 let 、 (( )) 和 [] 执行基本的算术操作。而在进行高级操作时,
#expr 和 bc 这两个工具也会非常有用

#let

no1=4;
no2=5;

let result=no1+no2
echo "4+5=$result"


let result++
let result++
let result+=6
let result-=6

# []

result=$[ no1 + no2 ]
echo "4+5=$result"

#expr
result=`expr 3 + 4`
echo "3+4=$result"

result=$(expr $no1 + 5)
result=`(expr $no1 + 5)`
echo "4+5=$result"

echo ---------------------bc--------------------------------
#bc bc 是一个用于数学运算的高级工具,这个精密计算器包含了大量的选项。我们可以
#借助它执行浮点数运算并应用一些高级函数
echo "计算浮点数4 * 0.56"
echo "4 * 0.56" | bc

no=54;
result=`echo "$no * 1.5" | bc`
echo $result

echo "设定小数精度.2 3/8"
echo "scale=2;3/8" | bc


echo bc进制转换
no=100
echo 100的2进制：
echo "obase=2;$no" | bc

no=1100100
echo 1100100的10进制：
echo "obase=10;ibase=2;$no" | bc

echo 计算平方以及平方根
echo "sqrt(100)" | bc #Square root
echo "10^10" | bc #Square



#!/bin/bash


#!/bin/bash

#在编写脚本的时候会频繁使用标准输入( stdin )、标准输出( stdout )和标准错误
#( stderr )
# 文件描述符
# 0 —— stdin (标准输入)
# 1 —— stdout (标准输出)
# 2 —— stderr (标准错误)


DIRNAME=$( dirname "$0")
DIR=$( cd "$DIRNAME" && pwd)

if [ -f "$DIR/temp.txt" -o -f "$DIR/out.txt" -o -f "$DIR/output.txt"  ];then
    rm -r  "$DIR/temp.txt"
    rm -r  "$DIR/out.txt"
    rm -r  "$DIR/output.txt"
    
fi

echo "This is a sample text 1" > temp.txt
echo "This is sample text 2" >> temp.txt
echo "是否成功：$? 0=成功"

#127	"command not found"	 	估计是$PATH不对, 或者是拼写错误
#cmd > output.txt 2>&1 
echo "是否成功：$?  127=command not found"
cmd 2>&1 | tee output.txt


# 错误重定向 
ls + 2> out.txt #正常运行
echo "是否成功：$? 2=严重错误"
#https://unix.stackexchange.com/questions/477390/ls-error-code-2



# 覆盖模式
cat<<EOF>log.txt
LOG FILE HEADER
This is a test log file
Function: System statistics
EOF

#cmd 2>/dev/null
#echo "是否成功：$?"



#!/bin/bash


dir=`pwd`
echo `pwd`

rm -f *.txt

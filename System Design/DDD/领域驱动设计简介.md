## Domain Driven Design

### 介绍

领域驱动设计（DDD）是一种基于模型驱动的软件设计方式。它以领域为核心，分析领域中的问题，通过建立一个领域模型来有效的解决领域中的核心的复杂问题。

Eric Ivans为领域驱动设计提出了大量的最佳实践和经验技巧。只有对领域的不断深入认识，才能得到一个解决领域核心问题的领域模型。

### 为什么使用DDD

#### 应对业务的复杂性

**如果一个应用的复杂性不是在技术方面的，而是在领域本身，即领域内的业务很复杂，使用领域驱动设计的价值就越大。**

#### 重构的苦恼

业务和系统总是不断变化的，除非公司倒闭了。

按照演进式设计的理论，让系统的设计随着系统承载业务的增长而改变，我们不需要作提前设计，就让系统伴随业务成长而演进。当然，这就不可避免的涉及到了重构。似乎每个人都在提重构。

重构是克服演进式设计中大杂烩问题的主力，通过在单独的类及方法级别上做一系列小步重构来完成。我们可以很容易重构出一个独立的类来放某些通用的逻辑，但是你会发现你很难给它一个业务上的含义，只能给予一个技术维度描绘的含义。这会带来什么问题呢？

- 新同学总是需要反复熟悉业务和查看代码，在脑海内重新将逻辑对应起来。
- 而且随着业务的变化，你重构完的代码往往又因为新业务的引起的修改再次腐烂。

事实上，你可能意识到问题之所在。在解决现实问题时，我们会将问题映射到脑海中的概念模型，在模型中解决问题，再将解决方案转换为实际的代码。上述问题在于我们解决了设计到代码之间的重构，但提炼出来的设计模型，并不具有实际的业务含义，这就导致在开发新需求时，其他同学并不能很自然地将业务问题映射到该设计模型。设计似乎变成了重构者的自娱自乐，代码继续腐败，重新重构……无休止的循环。

用DDD则可以很好地解决领域模型到设计模型的同步、演化，最后再将反映了领域的设计模型转为实际的代码。

> 模型是我们解决实际问题所抽象出来的概念模型，领域模型则表达与业务相关的事实；设计模型则描述了所要构建的系统。



## 贫血模型与失忆症

> **贫血领域对象**
>
> 贫血领域对象（Anemic Domain Object）是指仅用作数据载体，而没有行为的领域对象。

### 贫血模型

贫血模型最早广泛应用是源自于EJB2，最强盛时期则是由Spring创造，把“行为”（也称为逻辑、过程）和“状态”（可理解为数据，对应到语言就是对象成员变量）分离到不同的对象之中，那个只有状态的对象就是所谓的“贫血对象”（常称为VO——Value Object），而那个只有行为的对象就是我们常见的N层结构中的Logic/Service/Manager层（曾经Spring的作者Rod Johnson也承认，Spring不过是在沿袭EJB2时代的“事务脚本”，也就是面向过程编程）

**本质是数据与行为被割裂，分离。**

举个简单的J2EE的例子，设计一个与用户（User）相关的功能，传统的设计一般是：
类：User+UserManager
保存用户调用：userManager.save(User user);



**失忆症**

上面的save方法可能还比较简单，但是随着业务的增加，其中可能增加各种逻辑，这还只是一个方法，随着业务的增长原本属于某个对象的业务逻辑、状态会散落到大量这样的方法中，原本的代码意图会渐渐不明确，你渐渐不知道这个方法到底在干什么，它里面的基于怎样的复杂规则在运行，我们将这种情况成为由贫血症引起的失忆症。



### 充血模型

更好的是采用领域模型的开发方式，将**数据和行为封装在一起**，**并与现实世界中的业务对象相映射**。各类具备明确的职责划分，将领域逻辑分散到领域对象中，这也就是充血模型。

充血的设计则可能会是：
类：User
保存用户调用：user.save();
——User有一个行为是：保存它自己

我们发现充血的模型可能更多地映射了现实世界，如果人是一个对象，那么这个人洗脸刷牙学习等行为，应该是自己控制的，你能想象有一个“service”控制你吗？

### 难点

实际工程场景中使用充血模型会碰到很多细节问题，其中最大的难关就是“如何设计充血模型”或者说“如何从复杂的业务中分离出恰到好处且包含语义的行为逻辑放到模型中”



## DDD核心概念

### 统一语言

业务能力可以使用通用语言描述,比如创建一个订单(而不是往订单表插入一条数据)

其实写软件就像是翻译，把领域上的业务需求翻译成软件的各个功能。业务需求来自领域专家（Domain Expert），程序员们需要把领域专家的语言翻译成程序。如果程序员们翻译的时候使用的是自己的语言，而领域专家使用自己的行话，导致术语不一致，就会使得沟通不顺畅，难于消化知识。所以团队需要一种通用语言来进行沟通。这样的通用语言尽量以业务语言为主，而非技术语言。一开始的通用语言可能不尽完美，但它就像是代码一样，经常需要重构。例如：“创建一个订单”就比“插入一条订单数据”更容易让领域专家明白谈话的背景。



统一语言（Ubiquitous Language），是领域驱动设计中一个非常重要的概念。任何一个领域驱动设计的项目，都需要一种通用语言，一套通用的词汇。因为没有通用的语言，就没有一致的概念，沟通就会遇到障碍，最后的领域模型和软件也就无法满足领域内的真实业务需求。通用语言是领域专家和开发人员在对领域问题的沟通、需求的讨论、开发计划的制定、领域模型的设计，以及开发人员之间对领域模型的具体编码落地实现，等一系列过程中，所有人员使用的一种通用语言。话句话说，就是无论是沟通时所用的词汇、还是领域模型中的概念、还是代码中出现的类名与方法，只要是相同的意思，那就应该使用相同的词汇。可以看出，这种通用语言不是一下子就可以形成，而是在一个各方人员讨论的过程中，不断发现、明确，与精炼出来的。







### Bounded Context 限界上下文

用来对领域模型进行划分。Bounded Context有两层含义：

- Bounded，即有边界的，表示领域模型有边界；这个边界定义了模型的适用范围，以便让负责该模型的团队知道什么该在模型中实现，什么不该；
- Context，即领域模型的产生是在某个上下文中产生的；上下文是一个和环境相关的概念。比如一次头脑风暴会议大家达成了一个模型，那这次会议的讨论就是该模型的上下文；比如某本书中谈到了某个东西，那这个东西的上下文就是那本书，那个东西要有意义的前提离不开那本书这个上下文；所以，上下文是模型有意义的前提；



### 领域（Domain）、领域模型（Domain Model）、边界上下文（Bounded Context）的关系

- 领域就是业务问题域，业务问题空间；

- 领域模型是一种模型，表达了领域中哪些业务需求以及业务规则必须被满足；每一个领域中的问题，都会有一个对应的领域模型去解决；

- Bounded Context的作用是用来对`领域/领域模型`进行划分；划分Bounded Context就是将一个大的`领域/领域模型`划分为多个小的`领域/领域模型`；理论上，一个Domain/Domain Model可能会对应多个Bounded Context；同样，一个Bounded Context可能也会对应多个Domain/Domain Model，比如权限，用户等通用子域；所以他们之间没有绝对的关系。

  理想情况，一个Domain最好对应一个Bounded Context。



### 关于Domain、Sub Domain、Core Domain、Generic Domain，以及Shared Kernal的理解：

- 一个领域（Domain）会拆分为多个子领域（Sub Domain）；
- 子领域中最核心（最重要）的那个叫Core Domain；我们应该讲团队的核心资源用在核心子域上，因为它是产品成败的关键；
- 除了Core Domain外，其他的是支撑子域（Supporting Sub domain）；
- 有些支撑子域比较特殊，因为它解决的是一类通用问题，比如账号和权限；这类子域我们叫做通用子域（Generic Sub domain）；通常，通用子域对应的Bounded Context，会跨域多个子域；
- 多个子领域有时会有相交的部分，我们称作共享内核（Shared Kernel）；体现到代码上，就是同一份代码，在两个领域模型中复用；
- 一般只有Domain比较大的时候，我们才会划分出Sub Domain；

### 为什么一个大的领域模型需要划分？

因为，通常一个大的领域模型需要多个团队合作完成。如果多个团队基于一个共同的领域模型工作，由于每个团队的关注点不同，且一些看似叫法一样的概念，对于不同的团队，其背后的意思完全不同。所以，这样的概念含义模糊会给团队以及成员之间的合作带来很大的困扰。所以，我们需要通过一种手段（Bounded Context），将领域模型划分为不同的部分，确保同一个Bounded Context内的领域模型所表达的概念含义明确。然后，同一个Bounded Context下面，相关人员都使用一种统一的语言，以此来保证团队成员之间沟通能畅通无阻；



基本概念(聚合根、实体、值对象、领域服务、领域事件、资源库）

### 参考

https://www.cnblogs.com/netfocus/p/4492486.html



## DDD与微服务架构

DDD与微服务架构相得益彰

微服务架构众所周知，此处不做赘述。我们创建微服务时，需要创建一个高内聚、低耦合的微服务。而DDD中的限界上下文则完美匹配微服务要求，可以将该限界上下文理解为一个微服务进程。











## 落地Demo

美团：https://tech.meituan.com/2017/12/22/ddd-in-practice.html

## 参考

美团：https://tech.meituan.com/2017/12/22/ddd-in-practice.html

盒马：https://www.infoq.cn/article/alibaba-freshhema-ddd-practice

http://deepoove.com/blog/#/posts/69

http://ladder1984.github.io/post/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E6%B5%85%E6%9E%90/